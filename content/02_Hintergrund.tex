% !TEX root = ../Thesis.tex

\chapter{Theoretischer Hintergrund}
\label{ch:hintergrund}%
\index{Agenten-Architektur}%
\index{Tool-Nutzung}%
\index{Langkontext}%

\section{Grundkonzepte}

Das Kapitel führt in Grundbegriffe agentischer Systeme ein und bildet die theoretische Basis für Konzept und Implementierung.\footnote{Die Grundbegriffe basieren auf etablierten Konzepten aus der KI-Forschung, werden aber im Kontext von Software Engineering neu interpretiert.}

\subsection{Large Language Models: Grundlagen}

Large Language Models (LLMs)\index{Large Language Models!Grundlagen} sind neuronale Netze, die auf großen Textkorpora\index{Textkorpora!Training} trainiert wurden und menschenähnliche Textgenerierung ermöglichen~\cite{OpenAI2024GPT4,touvron2023llama}. Basierend auf der Transformer-Architektur\index{Transformer!Architektur}~\cite{vaswani2017attention} nutzen sie Selbstaufmerksamkeits-Mechanismen\index{Self-Attention} (Self-Attention), um kontextuelle Zusammenhänge über lange Sequenzen hinweg zu erfassen.

Moderne LLMs wie GPT-4, Claude 3.5 oder Llama 3 verfügen über Milliarden von Parametern und können durch \emph{Few-Shot-Learning}\index{Few-Shot-Learning} und \emph{In-Context-Learning}\index{In-Context-Learning} Aufgaben lösen, ohne explizit darauf trainiert zu werden. Das bildet die Grundlage für agentische Anwendungen\index{Agentische Anwendungen}.

\subsection{Von LLMs zu Agenten: Der Paradigmenwechsel}

Während klassische LLMs primär auf Textvervollständigung spezialisiert sind, zeichnen sich \emph{agentische Systeme} durch erweiterte Fähigkeiten aus~\cite{wang2023survey}. Zentral ist das \textbf{zielgerichtete Handeln}\index{Agent!Zielgerichtetheit}: Der Agent versteht übergeordnete Ziele und plant systematisch Schritte zur Zielerreichung\index{Zielerreichung}. Die \textbf{Werkzeugnutzung}\index{Externe Tools} ermöglicht die Integration externer Tools wie APIs, Datenbanken und Code-Execution\index{Code-Execution}, wodurch die Fähigkeiten über reine Textgenerierung hinausgehen. Ein persistentes \textbf{Gedächtnis}\index{Kontextpersistierung} speichert Kontextinformationen über mehrere Interaktionen hinweg und ermöglicht kontextbewusstes Arbeiten. Durch \textbf{Reflexion}\index{Selbstbewertung} erfolgt eine selbstkritische Bewertung eigener Outputs mit iterativer Verbesserung. Schließlich unterstützt \textbf{mehrschrittige Planung}\index{Task-Dekomposition} die Dekomposition komplexer Aufgaben in ausführbare Teilschritte.
Während klassische LLMs primär auf Textvervollständigung spezialisiert sind, zeichnen sich \emph{agentische Systeme} durch erweiterte Fähigkeiten aus~\cite{wang2023survey}. Zentral ist das \textbf{zielgerichtete Handeln}\index{Agent!Zielgerichtetheit}: Der Agent versteht übergeordnete Ziele und plant systematisch Schritte zur Zielerreichung\index{Zielerreichung}. Die \textbf{Werkzeugnutzung}\index{Externe Tools} ermöglicht die Integration externer Tools wie APIs, Datenbanken und Code-Ausführung\index{Code-Ausführung}, wodurch die Fähigkeiten über reine Textgenerierung hinausgehen. Ein persistentes \textbf{Gedächtnis}\index{Kontextpersistierung} speichert Kontextinformationen über mehrere Interaktionen hinweg und ermöglicht kontextbewusstes Arbeiten. Durch \textbf{Reflexion}\index{Selbstbewertung} erfolgt eine selbstkritische Bewertung eigener Outputs mit iterativer Verbesserung. Schließlich unterstützt \textbf{mehrschrittige Planung}\index{Task-Dekomposition} die Dekomposition komplexer Aufgaben in ausführbare Teilschritte.

\subsection{Agentic AI: Begriffe und Bausteine}

Kernbausteine agentischer Systeme sind \cite{weng2023prompt,yao2023react}:

\begin{description}
  \item[Zustand (State):] Umfasst aktuellen Kontext\index{State Management}, Ziele, Erinnerungen und Tool-Status\index{Tool-Status}. Der Zustand wird dynamisch aktualisiert\index{Zustandsaktualisierungen}.
  
  \item[Policy:] Steuert Entscheidungsprozesse (Planung, Aktion, Selbstkritik)\index{Policy!Entscheidungsfindung}. Kann regelbasiert\index{Regelbasierte Policy} oder LLM-gesteuert\index{LLM-gesteuerte Policy} sein.
  
  \item[Werkzeuge (Tools):] Externe Funktionen wie Code-Ausführung, Websuche\index{Websuche}, Dateizugriff, VCS-Operationen\index{VCS-Operationen}. Tools erweitern die Fähigkeiten des Agenten über reine Textgenerierung hinaus~\cite{schick2023toolformer,qin2023tool}.
  
  \item[Gedächtnis (Memory):] Speichert episodische (konkrete Ereignisse) und semantische (abstraktes Wissen) Informationen. Kann durch Vektor-Datenbanken oder strukturierte Speicher realisiert werden.
\end{description}

Orchestrierung koordiniert diese Komponenten durch Planung (z.\,B. ReAct-Pattern), Tool-Auswahl, Fehlerbehandlung und Reflexion~\cite{yao2023react}. Typische Artefakte in SE-Workflows sind strukturierte Schnittstellen über \textbf{JSON} und \textbf{YAML}, Datenpersistenz mittels \textbf{SQL}-Datenbanken sowie sichere Remote-Operationen über \textbf{SSH}. Darüber hinaus basieren viele Komponenten auf \textbf{ML}-Methoden und \textbf{NLP} für Code- und Textverstehen; Wissensrepräsentation erfolgt in \textbf{KB} (Wissensdatenbanken) und \textbf{KG} (Wissensgraphen). API-Interaktionen erfolgen üblicherweise über \textbf{HTTP} und \textbf{REST}, teils mit Fallbacks auf \textbf{XML}.

\subsection{Chain-of-Thought und Reasoning-Patterns}

\emph{Chain-of-Thought (CoT)} Prompting~\cite{wei2022chain} ermöglicht es LLMs, Zwischenschritte explizit zu formulieren. Das verbessert die Reasoning-Qualität erheblich:

\begin{quote}
\textit{\enquote{Let's think step by step}} — Typischer CoT-Prompt, der schrittweises Denken anregt
\end{quote}

Erweiterte Muster umfassen:
\begin{itemize}
  \item \textbf{ReAct} (Reasoning + Acting): Kombiniert Gedankenketten mit Tool-Aufrufen~\cite{yao2023react}
  \item \textbf{Tree-of-Thought}: Exploriert mehrere Reasoning-Pfade parallel
  \item \textbf{Reflexion}: Self-critique und iterative Verbesserung~\cite{shinn2023reflexion}
\end{itemize}

\subsection{Tool-Nutzung in LLMs}

Die Fähigkeit von LLMs, externe Werkzeuge zu nutzen, ist zentral für praktische Anwendungen. \emph{Toolformer}~\cite{schick2023toolformer} zeigte, dass LLMs lernen können, wann und wie Tools aufzurufen sind. ToolLLM~\cite{qin2023tool} erweiterte dies auf über 16.000 reale APIs.

Typischer Tool-Calling-Flow:
\begin{enumerate}
  \item Agent identifiziert Bedarf für externes Tool
  \item Generierung strukturierter Tool-Aufruf-Parameter (meist JSON)
  \item Ausführung durch Host-System
  \item Integration des Ergebnisses in Kontext
  \item Fortsetzung der Aufgabe
\end{enumerate}

\subsection{Etablierte Frameworks und Plattformen}

Praxisnahe Frameworks bieten Abstraktionen für agentische Systeme~\cite{wu2023autogen}:\footnote{\emph{ReAct} steht für \enquote{Reasoning and Acting} und ist eines der einflussreichsten Muster für agentische Systeme in der neueren Literatur.}

\begin{itemize}
  \item \textbf{LangChain}~\cite{chase2023langchain}: Modulare Komponenten für Chains, Agents, Memory
  \item \textbf{AutoGPT/BabyAGI}: Autonome Task-Decomposition und -Execution
  \item \textbf{MetaGPT}~\cite{hong2023metagpt}: Rollenbasierte Multi-Agent-Kollaboration
  \item \textbf{Generative Agents}~\cite{park2023generative}: Simulation menschlichen Verhaltens
\end{itemize}

\section{Verwandte Arbeiten}

Es existiert umfangreiche Literatur zu agentischen Systemen im Allgemeinen und ihrer Anwendung im Software Engineering im Besonderen. Der Abschnitt strukturiert relevante Arbeiten nach thematischen Schwerpunkten.

\subsection{Reasoning-and-Acting-Patterns}

\textbf{ReAct}~\cite{yao2023react} etablierte das grundlegende Pattern, bei dem LLMs explizit zwischen Reasoning-Schritten (Denken) und Acting-Schritten (Tool-Aufrufe) alternieren. Das Paper demonstrierte signifikante Verbesserungen bei question-answering und decision-making Tasks.
\textbf{ReAct}~\cite{yao2023react} etablierte das grundlegende Pattern, bei dem LLMs explizit zwischen Reasoning-Schritten (Denken) und Acting-Schritten (Tool-Aufrufe) alternieren. Das Paper demonstrierte signifikante Verbesserungen bei Question-Answering und Decision-Making-Tasks.

\textquote[\cite{yao2023react}]{Die Kombination von reasoning und acting führt zu robusteren und transparenteren Systemen, die besser nachvollziehbare Entscheidungen treffen.}

Die Vorteile umfassen:
\begin{itemize}
  \item Erhöhte Transparenz durch explizite Reasoning-Traces
  \item Bessere Fehlerdiagnose bei fehlgeschlagenen Tool-Aufrufen
  \item Möglichkeit zur Intervention und Korrektur
\end{itemize}

Grenzen sind längere Latenzen durch zusätzliche LLM-Aufrufe und potentielle Halluzinationen in Reasoning-Schritten.

\textbf{Reflexion}~\cite{shinn2023reflexion} erweitert ReAct um Self-Critique: Der Agent bewertet seine eigenen Outputs und lernt aus Fehlern durch verbale Bestärkung. Das verbessert die Erfolgsrate bei komplexen Tasks um bis zu \pct{20}.

\subsection{Software Engineering Agents}

Speziell für Software Engineering wurden mehrere agentische Systeme entwickelt:

\textbf{SWE-bench}~\cite{jimenez2023swe} ist ein Benchmark mit über 2.000 realen GitHub-Issues aus Python-Projekten. Es misst, ob Agenten eigenständig Pull Requests erstellen können, die die Issues lösen. Baseline-Systeme erreichen nur \pct{3}--\pct{5} Erfolgsrate, was die Schwierigkeit unterstreicht.

\textbf{SWE-agent}~\cite{yang2024sweagent} demonstrierte, dass optimierte Agent-Computer-Interfaces (ACIs) die Erfolgsrate auf \pct{12.5} steigern können. Zentral sind:
\begin{itemize}
  \item Spezialisierte Tools für Navigation, Suche und Editieren
  \item Kontextoptimierte Feedback-Formate
  \item Iterative Verfeinerungsschleifen
\end{itemize}

\textbf{Agentless}~\cite{zhang2024agentless} verfolgte einen minimalistischen Ansatz ohne persistentes Gedächtnis oder komplexe Planung und erreichte dennoch \pct{27} Erfolgsrate durch fokussierte Lokalisierung und Patching-Strategien. Das zeigt, dass nicht immer maximale Komplexität optimal ist.

\subsection{Multi-Agent-Systeme}

Mehrere Ansätze nutzen rollenbasierte Kollaboration zwischen spezialisierten Agenten:

\textbf{MetaGPT}~\cite{hong2023metagpt} simuliert ein Software-Team mit Rollen wie Produktmanager, Architekt, Entwickler und QS. Agents produzieren strukturierte Artefakte (PRDs, Designdokumente, Code, Tests) und folgen einem definierten Workflow.

\textbf{Generative Agents}~\cite{park2023generative} fokussierte auf realistische Simulation menschlichen Verhaltens durch episodisches Gedächtnis, Reflexion und Planung. Obwohl primär für Simulationen konzipiert, sind die Gedächtnis-Mechanismen auch für SE-Agents relevant.

\textbf{MINDSTORMS}~\cite{zhuge2023mindstorms} implementiert Societies-of-Mind-Konzepte mit natürlicher Sprache: Spezialisierte Sub-Agenten lösen Teilprobleme und kommunizieren über strukturierte Protokolle.

\subsection{Graph-/Workflow-basierte Orchestrierung}

Graphen erlauben robuste Kontrollflüsse (Retry, Branching, Parallelisierung), klare Zustandsübergänge und bessere Testbarkeit~\cite{wu2023autogen}. LangGraph erweitert LangChain um zustandsbasierte Graphen mit deterministischen Übergängen.

Vorteile:
\begin{itemize}
  \item Explizite Modellierung von Kontrollfluss
  \item Einfaches Debugging und Visualisierung
  \item Unterstützung für Streaming und Parallelisierung
\end{itemize}

Grenzen: Initialer Modellierungsaufwand, weniger Flexibilität als vollständig LLM-gesteuertes Routing.

\subsection{Evaluations-Benchmarks}

Neben SWE-bench existieren weitere Benchmarks:
\begin{itemize}
  \item \textbf{HumanEval/MBPP}: Code-Generierung aus Beschreibungen
  \item \textbf{APPS}: Algorithm-Problemlösung
  \item \textbf{CodeContests}: Competitive Programming Tasks
\end{itemize}

Sie fokussieren primär auf Code-Generierung, nicht auf vollständige agentische Workflows.

\section{Vergleich und Bewertung}

Tabelle~\ref{tab:agententypen} vergleicht typische Agententypen nach ihren Kernfähigkeiten. Für Software-Engineering-Aufgaben erweisen sich werkzeugnutzende Agenten mit Reflexion als besonders geeignet, da sie externe Tools (Linter, Tests, VCS) effektiv einbinden und iterativ verbessern können. Daraus leitet sich die in Kapitel~\ref{ch:konzept} entwickelte Architektur ab.

\begin{table}[ht]
\centering
\caption{Vergleich agentischer Systemtypen nach Fähigkeiten und Anwendungsbereich}
\label{tab:agententypen}
\begin{tabular}{L{3.5cm}L{4.5cm}L{4.5cm}}
\toprule
\cellcolor{headercolor}\textcolor{white}{\textbf{Agententyp}} & \cellcolor{headercolor}\textcolor{white}{\textbf{Kernfähigkeiten}} & \cellcolor{headercolor}\textcolor{white}{\textbf{Typischer Einsatz}} \\
\midrule
Reaktiver Agent & Direkte Stimulus-Response; kein Gedächtnis; schnelle Reaktionszeit & Einfache Klassifikation, FAQ-Bots, Code-Completion \\
\rowcolor{rowcolorgray}
Planender Agent & Zieldekomposition; Schrittplanung; kein Tool-Aufruf & Aufgabenplanung, Tutorialsysteme, Brainstorming \\
Werkzeugnutzender Agent & Tool-Integration; API-Calls; Code-Execution & Web-Search, Data Analysis, Simple Automation \\
\rowcolor{rowcolorgray}
Reflektierender Agent & Selbstkritik; Iterative Verbesserung; Fehlerkorrektur & Code Review, Qualitätssicherung, Optimization \\
Mehragentensystem & Rollenbasierte Kollaboration; Kommunikation; Spezialisierung & Komplexe SE-Workflows, Team-Simulation \\
\bottomrule
\end{tabular}
\end{table}

Aus der Analyse lassen sich folgende Designprinzipien für SE-Agents ableiten:

\begin{enumerate}
  \item \textbf{Tool-First-Design:} SE-Tasks erfordern Zugriff auf Entwicklungsumgebung (IDEs, CLI, Tests)
  \item \textbf{Reflexion ist essentiell:} Code-Qualität benötigt iterative Verbesserung
  \item \textbf{Kontextmanagement:} Lange Codebases erfordern effiziente Kontextfenster
  \item \textbf{Sicherheitsmechanismen:} Code-Ausführung erfordert Sandboxing und Validierung
\end{enumerate}

\section{Forschungslücke}

Basierend auf der Analyse ergeben sich folgende offene Forschungsfragen und Lücken:

\subsection{Architektonische Lücken}

\begin{itemize}
  \item \textbf{Fehlende Referenzarchitekturen:} Während Frameworks wie LangChain Bausteine bieten, fehlen validierte End-to-End-Architekturen für SE-Workflows
  \item \textbf{Tool-Interface-Design:} Unklar ist, wie Werkzeugschnittstellen optimal gestaltet werden sollten (granular vs. high-level, synchron vs. asynchron)
  \item \textbf{Gedächtnis-Strategien:} Welche Informationen sollten episodisch vs. semantisch gespeichert werden?
\end{itemize}

\subsection{Evaluations-Herausforderungen}

\begin{itemize}
  \item \textbf{Realistische Metriken:} SWE-bench misst nur Issue-Resolution, nicht Code-Qualität, Wartbarkeit oder Security
  \item \textbf{Kosten-Nutzen-Analysen:} Token-Kosten vs. Entwicklerzeit-Ersparnis sind schwer zu quantifizieren
  \item \textbf{Sicherheit und Robustheit:} Wie messen wir Resistenz gegen Prompt-Injection oder schädliche Tools?
\end{itemize}

\subsection{Skalierungs- und Kostenfragen}

\begin{itemize}
  \item \textbf{Langer Kontext:} Bei großen Codebases (\textgreater 100\,k LOC) stoßen selbst 1\,M-Token-Kontextfenster an Grenzen
  \item \textbf{Viele Tool-Aufrufe:} Jeder Tool-Call erhöht Latenz und Kosten
  \item \textbf{Parallelisierung:} Können unabhängige Teilaufgaben parallel bearbeitet werden?
\end{itemize}

\subsection{Beitrag der Arbeit}

Die Arbeit adressiert die identifizierten Lücken durch:

\begin{enumerate}
  \item Entwicklung einer dokumentierten Referenzarchitektur für SE-Agents
  \item Praxisnahe Implementierung mit Werkzeugschnittstellen-Richtlinien
  \item Evaluation anhand realistischer Metriken (Erfolgsrate, Qualität, Kosten, Safety)
  \item Ableitung von Best Practices für Kontextmanagement und Kostenoptimierung
\end{enumerate}

Die folgenden Kapitel beschreiben Konzept (Kapitel~\ref{ch:konzept}), Implementierung (Kapitel~\ref{ch:realisierung}) und Evaluation im Detail.

Zusätzlich zu den theoretischen Grundlagen ist es wichtig, die praktische Relevanz herauszustellen: Viele der hier diskutierten Patterns lassen sich unmittelbar in bestehende CI/CD-Pipelines integrieren und bieten dort schnelle Produktivitätsgewinne. Die anschließende Arbeit prüft deshalb nicht nur theoretische Eigenschaften, sondern evaluiert konkrete Integrationspfade in typische Entwickler-Workflows und berichtet über pragmatische Umsetzungsdetails, die den Transfer in produktive Umgebungen erleichtern. Die Kombination aus Theorie und Praxis bildet das Rückgrat der vorliegenden Untersuchung.
