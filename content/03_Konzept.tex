% !TEX root = ../Thesis.tex

\chapter{Konzept und Methodik}
\index{Design|Architektur-Design}
\index{Planung|Agent-Planung}
\index{Sicherheit}
\label{ch:konzept}

\section{Übersicht des Lösungsansatzes}

Aus Kapitel \ref{ch:hintergrund} abgeleitet entwerfen wir eine referenzierbare Agentenarchitektur für Software Engineering. Sie kombiniert Planung (Policy), Werkzeugnutzung (z.\,B. Linter, Tests, VCS), Gedächtnis (episodisch/semantisch) und Sicherheitsmechanismen (Filter, Sandboxing, Quoten).

\section{Architektur und Design}

Das Konzept basiert auf folgenden Designprinzipien:

\begin{itemize}
  \item Modularität: Komponenten sind unabhängig und austauschbar
  \item Skalierbarkeit: Das System wächst mit den Anforderungen
  \item Wartbarkeit: Code ist verständlich und dokumentiert
  \item Robustheit: Fehlertoleranz und Zuverlässigkeit
\end{itemize}

Abbildung \ref{fig:agent-architektur} zeigt eine schematische Architektur. Der \emph{Agent Controller} erhält ein Ziel, plant Schritte, ruft Tools auf (z.\,B. \enquote{Run Tests}, \enquote{Format Code}), schreibt relevante Informationen ins Gedächtnis und bewertet Zwischenergebnisse (Selbstkritik). Ein \emph{Safety Layer} erzwingt Richtlinien (z.\,B. Dateisystemzugriffe, Rate-Limits).

\begin{figure}[ht]
\centering
\begin{tikzpicture}[
  node distance=10mm and 14mm,
  every node/.style={font=\small},
  box/.style={draw, rounded corners, align=center, inner sep=4pt, minimum width=35mm, minimum height=10mm},
  io/.style={draw, align=center, inner sep=4pt, minimum width=30mm, minimum height=8mm},
  >={Stealth[length=2.2mm]}
]
% Nodes
\node[io] (input) {Eingabe\\(Ziel)};
\node[box, right=of input] (controller) {Agent Controller\\(Planung / Policy)};
\node[box, right=of controller] (tools) {Tool-Adapter\\(Linter, Tests, VCS)};
\node[box, below=of tools] (memory) {Gedächtnis\\(episodisch / semantisch)};
\node[io, right=of tools] (output) {Ausgabe\\(Vorschlag / Patch)};

% Safety layer (fit around core components)
\node[draw, rounded corners, fit=(controller) (tools) (memory), inner sep=6mm, label={[align=center]above:Safety Layer\\(Sandboxing, Filter, Quoten)}] (safety) {};

% Edges
\draw[->] (input) -- (controller);
\draw[->] (controller) -- (tools);
\draw[->] (tools) -- (output);
\draw[->] (controller) |- (memory);
\draw[->] (memory) -| (controller);

\end{tikzpicture}
\caption{Agentenarchitektur für Software Engineering mit agentic AI (TikZ-Diagramm)}
\label{fig:agent-architektur}
\end{figure}

\section{Mathematische Grundlagen}

Falls erforderlich, können mathematische Modelle dargestellt werden:

\[
  f(x) = \sum_{i=1}^{n} x_i \cdot w_i
\]

wobei $x_i$ die Eingabewerte und $w_i$ die Gewichtungen darstellen.

\section{Methodik}

Abbildung \ref{fig:agent-workflow} illustriert den typischen Ablauf einer agentischen Sitzung. Der Agent empfängt ein Ziel, plant Schritte, führt Tools sequenziell aus, sammelt Feedback und entscheidet über weitere Schritte (Schleife) bis zur Fertigstellung.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[
  node distance=10mm and 18mm,
  every node/.style={font=\small},
  actor/.style={draw, rectangle, align=center, inner sep=4pt, minimum width=28mm, minimum height=8mm},
  action/.style={draw, diamond, aspect=2, align=center, inner sep=3pt},
  >={Stealth[length=2.2mm]}
]
% Actors/Components
\node[actor] (agent) {Agent};
\node[actor, right=of agent] (tools) {Tools};
\node[actor, below=of agent] (feedback) {Feedback};

% Sequence of actions
\node[action, below=of tools, xshift=-10mm] (plan) {\small Plan};
\node[below=of plan, yshift=2mm] (call) {\small Call Tool};
\node[below=of call, yshift=2mm] (result) {\small Result};
\node[below=of result, yshift=2mm] (decide) {\small Entscheiden};

% Arrows showing sequence
\draw[->] (agent.south) -- (plan.north) node[midway, right, font=\tiny] {1};
\draw[->] (plan.east) -- (tools.west) node[midway, above, font=\tiny] {2};
\draw[->] (tools.south) -- (result.north) node[midway, right, font=\tiny] {3};
\draw[->] (result.west) -- (decide.east) node[midway, below, font=\tiny] {4};
\draw[->] (decide.south) -- (feedback.east) node[midway, left, font=\tiny] {5};

% Loop indication
\draw[->, dashed] (feedback.north) -| (agent.south) node[midway, left, font=\tiny] {Schleife};

\end{tikzpicture}
\caption{Workflow eines agentischen Systems: Planung, Tool-Ausführung, Feedback-Schleife}
\label{fig:agent-workflow}
\end{figure}

Die Realisierung folgt einem systematischen Vorgehen und referenziert Tabelle \ref{tab:agententypen} sowie Abbildung \ref{fig:agent-architektur}:

\begin{enumerate}
  \item Anforderungsanalyse: Präzise Definition der Ziele
  \item Designphase: Architektur und Schnittstellen festlegen
  \item Implementierungsphase: Umsetzung des Designs
  \item Testphase: Validierung und Verifikation
  \item Optimierungsphase: Performance und Qualität verbessern
\end{enumerate}

\section{Abgrenzung zu alternativen Ansätzen}

Dieser Ansatz unterscheidet sich von den in Kapitel \ref{ch:hintergrund} beschriebenen Methoden durch:

\begin{itemize}
  \item Verbesserte Effizienz durch optimierte Algorithmen
  \item Bessere Skalierungseigenschaften
  \item Praktischere Anwendbarkeit
\end{itemize}
