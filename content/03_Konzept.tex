% !TEX root = ../Thesis.tex

\chapter{Konzept und Methodik}
\index{Design|Architektur-Design}
\index{Planung|Agent-Planung}
\index{Sicherheit}
\label{ch:konzept}

\section{Übersicht des Lösungsansatzes}

Aus Kapitel \ref{ch:hintergrund} abgeleitet entwerfen wir eine referenzierbare Agentenarchitektur für Software Engineering. Sie kombiniert Planung (Policy), Werkzeugnutzung (z.\,B. Linter, Tests, VCS), Gedächtnis (episodisch/semantisch) und Sicherheitsmechanismen (Filter, Sandboxing, Quoten).\footnote{\emph{Referenzierbar} bedeutet hier, dass die Architektur dokumentiert und in anderen Projekten anwendbar ist.}

\section{Architektur und Design}

Das Konzept basiert auf folgenden Designprinzipien:\footnote{Diese Prinzipien orientieren sich an etablierten Softwareentwicklungs-Patterns und Best Practices.}

\begin{itemize}
  \item Modularität: Komponenten sind unabhängig und austauschbar
  \item Skalierbarkeit: Das System wächst mit den Anforderungen
  \item Wartbarkeit: Code ist verständlich und dokumentiert
  \item Robustheit: Fehlertoleranz und Zuverlässigkeit
\end{itemize}

Abbildung \ref{fig:agent-architektur} zeigt eine schematische Architektur. Der \emph{Agent Controller} erhält ein Ziel, plant Schritte, ruft Tools auf (z.\,B. \enquote{Run Tests}, \enquote{Format Code}), schreibt relevante Informationen ins Gedächtnis und bewertet Zwischenergebnisse (Selbstkritik). Ein \emph{Safety Layer} erzwingt Richtlinien (z.\,B. Dateisystemzugriffe, Rate-Limits).

\begin{figure}[ht]
\centering
\begin{tikzpicture}[
  node distance=10mm and 14mm,
  every node/.style={font=\small},
  box/.style={draw, rounded corners, align=center, inner sep=4pt, minimum width=35mm, minimum height=10mm},
  io/.style={draw, align=center, inner sep=4pt, minimum width=30mm, minimum height=8mm},
  >={Stealth[length=2.2mm]}
]
% Nodes
\node[io] (input) {Eingabe\\(Ziel)};
\node[box, right=of input] (controller) {Agent Controller\\(Planung / Policy)};
\node[box, right=of controller] (tools) {Tool-Adapter\\(Linter, Tests, VCS)};
\node[box, below=of tools] (memory) {Gedächtnis\\(episodisch / semantisch)};
\node[io, right=of tools] (output) {Ausgabe\\(Vorschlag / Patch)};

% Safety layer (fit around core components)
\node[draw, rounded corners, fit=(controller) (tools) (memory), inner sep=6mm, label={[align=center]above:Safety Layer\\(Sandboxing, Filter, Quoten)}] (safety) {};

% Edges
\draw[->] (input) -- (controller);
\draw[->] (controller) -- (tools);
\draw[->] (tools) -- (output);
\draw[->] (controller) |- (memory);
\draw[->] (memory) -| (controller);

\end{tikzpicture}
\caption{Agentenarchitektur für Software Engineering mit agentic AI (TikZ-Diagramm)}
\label{fig:agent-architektur}
\end{figure}

\section{Mathematische Grundlagen}

Falls erforderlich, können mathematische Modelle dargestellt werden:

\[
  f(x) = \sum_{i=1}^{n} x_i \cdot w_i
\]

wobei $x_i$ die Eingabewerte und $w_i$ die Gewichtungen darstellen.

\section{Methodik}

Abbildung \ref{fig:agent-workflow} illustriert den typischen Ablauf einer agentischen Sitzung. Der Agent empfängt ein Ziel, plant Schritte, führt Tools sequenziell aus, sammelt Feedback und entscheidet über weitere Schritte (Schleife) bis zur Fertigstellung.

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{images/agent-workflow.png}
\caption{Workflow eines agentischen Systems: Planung, Tool-Ausführung, Feedback-Schleife (Mermaid-Diagramm)}
\label{fig:agent-workflow}
\end{figure}

Die Realisierung folgt einem systematischen Vorgehen und referenziert Tabelle \ref{tab:agententypen} sowie Abbildung \ref{fig:agent-architektur}:

\begin{enumerate}
  \item Anforderungsanalyse: Präzise Definition der Ziele
  \item Designphase: Architektur und Schnittstellen festlegen
  \item Implementierungsphase: Umsetzung des Designs
  \item Testphase: Validierung und Verifikation
  \item Optimierungsphase: Performance und Qualität verbessern
\end{enumerate}

\section{Abgrenzung zu alternativen Ansätzen}

Dieser Ansatz unterscheidet sich von den in Kapitel \ref{ch:hintergrund} beschriebenen Methoden durch:

\begin{itemize}
  \item Verbesserte Effizienz durch optimierte Algorithmen
  \item Bessere Skalierungseigenschaften
  \item Praktischere Anwendbarkeit
\end{itemize}
