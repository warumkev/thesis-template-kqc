\chapter{Einführung}
\index{Agentic AI}
\index{Software Engineering}

% Längeres abgesetztes Zitat
\begin{quote}
\textit{\textquote[\cite{karpathy2023intro}]{Wir erleben die Entstehung eines neuen Betriebssystems: Das LLM fungiert als Kernel-Prozess, das Kontext-Fenster als Arbeitsspeicher und externe Werkzeuge als I/O-Schnittstellen. Dies markiert einen fundamentalen Wandel in der Art und Weise, wie wir Computerinstruktionen komponieren und Software-Architekturen denken.}}
\smallskip
\begin{flushright}
— Andrej Karpathy, \textit{Intro to Large Language Models}, 2023
\end{flushright}
\end{quote}

\section{Motivation und Relevanz}

Software Engineering erlebt derzeit einen Paradigmenwechsel: \emph{agentic AI} \textendash{} also KI-Systeme, die Ziele verstehen, Pläne erstellen, Werkzeuge verwenden und Ergebnisse eigenständig verifizieren \textendash{} ergänzt klassische Automatisierung um adaptive, mehrschrittige Problemlösung.\footnote{Der Begriff \emph{Agentic AI} wird derzeit von führenden Forschungsteams geprägt und bezieht sich auf Systeme, die über mehrere Schritte selbstständig komplexe Aufgaben bewältigen können.}
 
Darüber hinaus verlangt die praktische Anwendung agentischer Systeme oft einen ausgewogenen Kompromiss zwischen Automatisierung und menschlicher Kontrolle. In vielen Entwicklungsprozessen sind Schritte, die bisher rein manuell durchgeführt wurden (Code-Reviews, Testgenerierung, Release-Checks), gute Kandidaten für assistierte Workflows. Agenten können Routinearbeit übernehmen, erlauben dadurch jedoch auch neue Prüfpfade: So müssen Validierungsstrategien entworfen werden, die automatisierte Entscheidungen nachvollziehbar machen und menschliche Reviewer bei Bedarf schnell eingreifen lassen. Diese Arbeit nimmt genau diesen Balanceakt in den Blick und liefert pragmatische Designprinzipien für den produktiven Einsatz.
Wie Richards und Ford betonen, \textquote[\cite{richards2020fundamentals}]{müssen Architekturprinzipien auf Skalierbarkeit und Wartbarkeit ausgelegt sein}, um praktischen Anforderungen gerecht zu werden.
Für Informatikstudierende der Fachrichtung \enquote{Software Engineering mit agentic AI} eröffnet dies neue Architektur- und Methodikfragen: Wie entwirft man robuste Agenten-Workflows? Wie orchestriert man Tool-Nutzung, Gedächtnis und Langkontext? Und wie integriert man Sicherheit, Nachvollziehbarkeit und Tests in agentische Systeme?\footnote{Praktische Orchestrierung bedeutet hier die Koordination von Planungsschritten, Werkzeugaufrufen und Gedächtniszugriffen in einer strukturierten Abfolge.}

\section{Problemstellung}

Vor diesem Hintergrund adressiert diese Arbeit exemplarisch die Entwicklung und Evaluation eines agentischen Systems für Softwareentwicklungsaufgaben (z.\,B. Refactoring, Code-Review, Generierung von Tests). Zentrale Fragen sind:

\begin{itemize}
  \item Wie lassen sich Agenten-Policies (Planen, Tool-Aufrufe, Selbstkritik) systematisch modellieren?
  \item Wie werden externe Werkzeuge (VCS, CI, linters, Issue-Tracker) sicher und nachvollziehbar eingebunden?
  \item Welche Metriken messen Fortschritt, Qualität und Sicherheit realistisch?
\end{itemize}
 
Die hier formulierten Probleme sind sowohl konzeptioneller als auch praktischer Natur: Es geht nicht nur um abstrakte Modellierung von Policies, sondern ebenso um konkrete Implementationsfragen (Schnittstellen, Serialisierung, Fehlerbehandlung) und Evaluationsdesign (Benchmarks, Messgrößen, Reproduzierbarkeit). Die Ergebnisse sollen Entwicklerteams konkrete Handlungsempfehlungen geben, wie agentische Automatisierung schrittweise, sicher und messtechnisch abgesichert eingeführt werden kann.\index{Evaluation}
\section{Zielsetzung}

Die Ziele dieser Arbeit sind auf die Spezialisierung \enquote{Software Engineering mit agentic AI} zugeschnitten:\footnote{Siehe auch \cite{wang2023survey} für verwandte Arbeiten zu Agentenarchitekturen.}

\begin{enumerate}
  \item Analyse des Forschungsstands zu agentischen Architekturen und Orchestrierungsframeworks
  \item Entwurf einer referenzierbaren Agentenarchitektur für Software-Engineering-Aufgaben
  \item Implementierung eines prototypischen Agenten mit Werkzeuganbindung und Gedächtnis
  \item Evaluation anhand reproduzierbarer Benchmarks (Qualität, Kosten, Laufzeit, Sicherheit)
\end{enumerate}
 
Kurz gefasst zielt die Arbeit darauf ab, aus Praxisproblemen generalisierbare Lösungen abzuleiten: Neben einem lauffähigen Prototyp steht die Frage im Vordergrund, welche Architekturmuster sich zuverlässig übertragen lassen und welche Messgrößen praktikabel den Mehrwert gegenüber manuellen Prozessen quantifizieren. Damit richtet sich die Arbeit an Praktiker und Forschende gleichermaßen.
\section{Abgrenzung des Themas}

Die Arbeit fokussiert Agenten für Softwareentwicklungsaufgaben. Nicht im Fokus sind z.\,B. Reinforcement Learning from Human Feedback (RLHF) im Detail, Trainingsmethoden auf Rohdaten oder proprietäre Interna von Foundation Models. Ebenso werden Domänen außerhalb der Softwareentwicklung (z.\,B. Robotik) nicht betrachtet.

\begin{itemize}
  \item Zu komplexe Spezialfälle, die für diese Arbeit nicht relevant sind
  \item Historische Entwicklungen vor einem bestimmten Zeitpunkt
  \item Randbereiche, die außerhalb des Fokus liegen
\end{itemize}
 
Die Konzentration auf pragmatische, reproduzierbare Ergebnisse erlaubt es, bewusst auf tiefe ML-Trainingsfragen zu verzichten; stattdessen wird die Interaktion mit bestehenden Foundation Models über APIs und Adapterlösungen untersucht. Diese Fokussierung erleichtert die Nachvollziehbarkeit der Ergebnisse und erhöht die direkte Anwendbarkeit in typischen Software-Engineering-Umgebungen.
\section{Aufbau der Arbeit}

Der Aufbau der Arbeit folgt einem pragmatischen Workflow: Zunächst werden in Kapitel~\ref{ch:hintergrund} die relevanten Grundlagen und verwandte Arbeiten zusammengetragen, um die fachliche Basis zu legen. Darauf aufbauend beschreibt Kapitel~\ref{ch:konzept} die entworfene Referenzarchitektur mit Fokus auf Zustandsmodellierung, Policy-Design und Schnittstellen. Kapitel~\ref{ch:realisierung} dokumentiert die Implementierung des Prototyps, zeigt zentrale Code-Beispiele und erläutert Integrationsdetails. Abschließend fasst Kapitel~\ref{ch:abschluss} die Ergebnisse zusammen, diskutiert Limitationen und gibt einen Ausblick auf weiterführende Forschungs- und Entwicklungsfragen.

Insgesamt soll die Arbeit nicht nur eine theoretische Diskussion bieten, sondern konkrete, übertragbare Architekturentscheidungen und Metriken bereitstellen, die in produktiven Entwicklungsumgebungen einsetzbar sind.\index{Agentenarchitektur}
